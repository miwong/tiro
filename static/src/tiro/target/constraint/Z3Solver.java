package tiro.target.constraint;

import tiro.Output;

import soot.*;

import com.microsoft.z3.*;
import org.apache.commons.lang3.math.NumberUtils;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Z3Solver {
    private final Predicate _constraint;
    private final com.microsoft.z3.Context _context;
    private final Model _model;
    private final Map<SymbolicVariable, Expr> _variableMap =
            new HashMap<SymbolicVariable, Expr>();

    public Z3Solver(Predicate constraint) {
        _constraint = constraint;
        _context = new com.microsoft.z3.Context();
        _model = generateModel();
    }

    public static void inputValuesSanityCheck(Predicate constraint) {
        if (constraint == null) {
            return;
        }

        Set<Variable> variables = constraint.searchVariables(v -> {
            return v.dependsOnInput();
        });

        if (variables.isEmpty()) {
            return;
        }

        Z3Solver solver = new Z3Solver(constraint);
        if (solver.isSatisfiable()) {
            for (Variable variable : variables) {
                String value = solver.getVariableValue(variable);
                Output.debug("Solved input variable: " + variable.toString() + " = " + value);
            }
        }
    }

    public static boolean isSatisfiable(Predicate constraint) {
        Z3Solver solver = new Z3Solver(constraint);
        return solver.isSatisfiable();
    }

    public boolean isSatisfiable() {
        return _model != null;
    }

    public String getVariableValue(Variable variable) {
        Expr variableExpr = getVariableExpr(variable);
        if (variableExpr == null) {
            return null;
        }

        // If this is a string expr, use getString() to remove the quotations generated by Z3.
        if (variableExpr.isString()) {
            return variableExpr.getString();
        } else {
            return variableExpr.toString();
        }
    }

    public boolean getVariableValueAsBoolean(Variable variable) {
        String variableValue = getVariableValue(variable);
        return (variableValue != null) ? (Integer.valueOf(variableValue) == 1) : false;
    }

    public int getVariableValueAsInt(Variable variable) {
        String variableValue = getVariableValue(variable);
        return (variableValue != null) ? Integer.valueOf(variableValue) : -1;
    }

    public long getVariableValueAsLong(Variable variable) {
        String variableValue = getVariableValue(variable);
        return (variableValue != null) ? Long.valueOf(variableValue) : -1L;
    }

    public float getVariableValueAsFloat(Variable variable) {
        String variableValue = getVariableValue(variable);
        return (variableValue != null) ? Float.valueOf(variableValue) : -1.0F;
    }

    public double getVariableValueAsDouble(Variable variable) {
        String variableValue = getVariableValue(variable);
        return (variableValue != null) ? Double.valueOf(variableValue) : -1.0D;
    }

    private Expr getVariableExpr(Variable variable) {
        if (_model == null) {
            Output.error("Z3Solver: unable to create constraint model");
            return null;
        }
        if (!variable.isSymbolic()) {
            Output.error("Z3Solver: trying to obtain non-symbolic variable value");
            return null;
        }

        SymbolicVariable symbolicVariable = (SymbolicVariable)variable;
        if (_variableMap.containsKey(symbolicVariable)) {
            return _model.evaluate(_variableMap.get(symbolicVariable), true);
        }

        return null;
    }

    private Model generateModel() {
        Solver solver = _context.mkSolver();

        // Add a 10 second timeout for constraint solving.
        Params params = _context.mkParams();
        params.add("timeout", 10000);
        solver.setParameters(params);

        try {
            BoolExpr constraintExpr = generateBoolExpr(_constraint);
            solver.add(constraintExpr);
            Status status = solver.check();

            if (status == Status.SATISFIABLE) {
                return solver.getModel();
            } else if (status == Status.UNKNOWN) {
                Output.warn("Z3Solver: timeout during constraint model check");
                return null;
            } else {
                //Output.warn("Z3Solver: constraint model not satisfiable");
                return null;
            }
        } catch (Exception e) {
            Output.error("Z3Solver: cannot resolve constraint");
            return null;
        }
    }

    private BoolExpr generateBoolExpr(Predicate constraint) {
        // In cases where the constraints are complex (e.g. in a long method with many loops),
        // make sure that we detect timeouts and stop analysis in for the current path.
        //if (Thread.interrupted()) {
        //    throw new StaticAnalysisTimeoutException("ConstraintAnalysis");
        //}

        if (constraint.isExpression()) {
            return (BoolExpr)generateExpr(((ExpressionPredicate)constraint).getExpression());
        } else if (constraint.isUnary()) {
            BoolExpr leftExpr = generateBoolExpr(((UnaryPredicate)constraint).getChild());
            return resolveLogicOperator(constraint.getOperator(), leftExpr);
        } else if (constraint.isBinary()) {
            BoolExpr leftExpr =
                    generateBoolExpr(((BinaryPredicate)constraint).getLeftChild());
            BoolExpr rightExpr =
                    generateBoolExpr(((BinaryPredicate)constraint).getRightChild());
            return resolveLogicOperator(constraint.getOperator(), leftExpr, rightExpr);
        }

        return null;
    }

    private Expr generateExpr(Expression expr) {
        if (expr.isVariable()) {
            return resolveVariableExpression(expr.toVariableExpression());

        } else if (expr.isStringExpression()) {
            StringExpression stringExpr = expr.toStringExpression();
            return resolveStringExpression(stringExpr);

        } else if (expr.isArithmeticExpression()) {
            ArithmeticExpression arithExpr = expr.toArithmeticExpression();
            return resolveArithmeticExpression(arithExpr);

            //if (Expression.isBitwiseOperator(expr.getOperator())) {
            //    return resolveBitwiseOperator(expr.getOperator(), leftExpr, rightExpr);
            //} else {
            //    return resolveOperator(expr.getOperator(), leftExpr, rightExpr);
            //}
        }

        return null;
    }

    private BoolExpr resolveLogicOperator(Predicate.Operator operator, BoolExpr... operands) {
        switch (operator) {
            case AND: return _context.mkAnd(operands[0], operands[1]);
            case OR:  return _context.mkOr(operands[0], operands[1]);
            case NOT: return _context.mkNot(operands[0]);
            default:  return null;
        }
    }

    private Expr resolveArithmeticExpression(ArithmeticExpression arithExpr) {
        Expr leftExpr = generateExpr(arithExpr.getLeft());
        Expr rightExpr = generateExpr(arithExpr.getRight());

        if (Variable.isFloatingPointType(arithExpr.getType())) {
            FPExpr fpLeft = (FPExpr)leftExpr;
            FPExpr fpRight = (FPExpr)rightExpr;
            FPRMExpr rm = (FPRMExpr)_context.mkConst(_context.mkSymbol("rm"),
                    _context.mkFPRoundingModeSort());

            switch (arithExpr.getOperator()) {
                case ADD: return _context.mkFPAdd(rm, fpLeft, fpRight);
                case SUB: return _context.mkFPSub(rm, fpLeft, fpRight);
                case MUL: return _context.mkFPMul(rm, fpLeft, fpRight);
                case DIV: return _context.mkFPDiv(rm, fpLeft, fpRight);
                case GT:  return _context.mkFPGt(fpLeft, fpRight);
                case GE:  return _context.mkFPGEq(fpLeft, fpRight);
                case LT:  return _context.mkFPLt(fpLeft, fpRight);
                case LE:  return _context.mkFPLEq(fpLeft, fpRight);
                case EQ:  return _context.mkFPEq(fpLeft, fpRight);
                case NE:  return _context.mkNot(_context.mkFPEq(fpLeft, fpRight));
                default:  break;
            }
        } else {
            BitVecExpr bvLeft = (BitVecExpr)leftExpr;
            BitVecExpr bvRight = (BitVecExpr)rightExpr;
            switch (arithExpr.getOperator()) {
                case ADD: return _context.mkBVAdd(bvLeft, bvRight);
                case SUB: return _context.mkBVSub(bvLeft, bvRight);
                case MUL: return _context.mkBVMul(bvLeft, bvRight);
                case DIV: return _context.mkBVSDiv(bvLeft, bvRight);
                case REM: return _context.mkBVSRem(bvLeft, bvRight);
                case GT:  return _context.mkBVSGT(bvLeft, bvRight);
                case GE:  return _context.mkBVSGE(bvLeft, bvRight);
                case LT:  return _context.mkBVSLT(bvLeft, bvRight);
                case LE:  return _context.mkBVSLE(bvLeft, bvRight);
                case EQ:  return _context.mkEq(bvLeft, bvRight);
                case NE:  return _context.mkNot(_context.mkEq(bvLeft, bvRight));
                case AND: return _context.mkBVAND(bvLeft, bvRight);
                case OR:  return _context.mkBVOR(bvLeft, bvRight);
                case XOR: return _context.mkBVXOR(bvLeft, bvRight);
                case SHL: return _context.mkBVSHL(bvLeft, bvRight);
                case SHR: return _context.mkBVLSHR(bvLeft, bvRight);
                default:  break;
            }
        }

        Output.error("Z3Solver: cannot represent arithmetic constraint " + arithExpr);
        return null;
    }

    private Expr resolveStringExpression(StringExpression stringExpr) {
        SeqExpr leftExpr = (SeqExpr)generateExpr(stringExpr.getLeft());
        SeqExpr rightExpr = (SeqExpr)generateExpr(stringExpr.getRight());

        switch (stringExpr.getOperator()) {
            case STR_EQ:    return _context.mkAnd(_context.mkContains(leftExpr, rightExpr),
                                                  _context.mkContains(rightExpr, leftExpr));
            case STR_NE:    return _context.mkNot(_context.mkAnd(
                                       _context.mkContains(leftExpr, rightExpr),
                                       _context.mkContains(rightExpr, leftExpr)));
            case APPEND:    return _context.mkConcat(leftExpr, rightExpr);
            case CONTAINS:  return _context.mkContains(leftExpr, rightExpr);
            case INDEX_OF:  return _context.mkIndexOf(leftExpr, rightExpr, _context.mkInt(0));
            case PREFIX_OF: return _context.mkPrefixOf(leftExpr, rightExpr);
            case SUFFIX_OF: return _context.mkSuffixOf(leftExpr, rightExpr);
            default:        break;
        }

        Output.error("Z3Solver: cannot represent string constraint " + stringExpr);
        return null;
    }

    private Expr resolveVariableExpression(final VariableExpression expr) {
        final Variable variable = expr.getVariable();

        // Check if constant value.
        if (variable.isConstant()) {
            TypeSwitch typeSwitch = new TypeSwitch() {
                @Override
                public void caseArrayType(ArrayType t) {
                    setResult(_context.mkBV(0, 32));
                }
                @Override
                public void caseBooleanType(BooleanType t) {
                    int booleanValue = ((BooleanVariable)variable).getValue().booleanValue()
                            ? 1 : 0;
                    setResult(_context.mkBV(booleanValue, 1));
                }
                @Override
                public void caseByteType(ByteType t) {
                    setResult(_context.mkBV(((NumberVariable)variable).getValue().intValue(),
                            8));
                }
                @Override
                public void caseCharType(CharType t) {
                    setResult(_context.mkBV(((NumberVariable)variable).getValue().intValue(),
                            8));
                }
                @Override
                public void caseDoubleType(DoubleType t) {
                    setResult(_context.mkFP(
                            ((NumberVariable)variable).getValue().doubleValue(),
                            _context.mkFPSortDouble()));
                }
                @Override
                public void caseFloatType(FloatType t) {
                    setResult(_context.mkFP(((NumberVariable)variable).getValue().floatValue(),
                                         _context.mkFPSortSingle()));
                }
                @Override
                public void caseIntType(IntType t) {
                    setResult(_context.mkBV(((NumberVariable)variable).getValue().intValue(),
                            32));
                }
                @Override
                public void caseLongType(LongType t) {
                    setResult(_context.mkBV(
                            ((NumberVariable)variable).getValue().longValue(), 64));
                }
                @Override
                public void caseNullType(NullType t) {
                    // Null is handled a bit differently based on the outer expression type.
                    if (Variable.isStringType(expr.getType())) {
                        setResult(_context.mkString(""));
                    } else {
                        setResult(_context.mkBV(0, 32));
                    }
                }
                @Override
                public void caseRefType(RefType t) {
                    if (Variable.isStringType(t)) {
                        setResult(_context.mkString(((StringVariable)variable).getValue()));
                    } else {
                        setResult(_context.mkBV(0, 32));
                    }
                }
                @Override
                public void caseShortType(ShortType t) {
                    setResult(_context.mkBV(((NumberVariable)variable).getValue().intValue(),
                            16));
                }
                @Override
                public void caseVoidType(VoidType t) {
                    // Null is handled a bit differently based on the outer expression type.
                    if (Variable.isStringType(expr.getType())) {
                        setResult(_context.mkString(""));
                    } else {
                        setResult(_context.mkBV(0, 32));
                    }
                }
                @Override
                public void defaultCase(Type t) {
                    Output.error("Unsupported constraint constant variable type: " + t);
                    setResult(_context.mkBV(0, 32));
                }
            };

            expr.getType().apply(typeSwitch);
            return (Expr)typeSwitch.getResult();
        }

        // Not a constant, so obtain from symbolic variable map (or generate if needed).
        return _variableMap.computeIfAbsent(
                (SymbolicVariable)variable, k -> generateSymbolicVariable(expr, k));
    }

    private Expr generateSymbolicVariable(VariableExpression expr, SymbolicVariable variable) {
        TypeSwitch typeSwitch = new TypeSwitch() {
            @Override
            public void caseArrayType(ArrayType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(32)));
            }
            @Override
            public void caseBooleanType(BooleanType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(1)));
            }
            @Override
            public void caseByteType(ByteType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(8)));
            }
            @Override
            public void caseCharType(CharType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(8)));
            }
            @Override
            public void caseDoubleType(DoubleType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkFPSortDouble()));
            }
            @Override
            public void caseFloatType(FloatType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkFPSortSingle()));
            }
            @Override
            public void caseIntType(IntType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(32)));
            }
            @Override
            public void caseLongType(LongType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(64)));
            }
            @Override
            public void caseRefType(RefType t) {
                if (Variable.isStringType(t)) {
                    setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                            _context.getStringSort()));
                } else {
                    setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                            _context.mkBitVecSort(32)));
                }
            }
            @Override
            public void caseShortType(ShortType t) {
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(16)));
            }
            @Override
            public void defaultCase(Type t) {
                Output.error("Unsupported constraint symbolic variable type: " + t);
                setResult(_context.mkConst(_context.mkSymbol(variable.getSymbol()),
                        _context.mkBitVecSort(32)));
            }
        };

        expr.getType().apply(typeSwitch);
        return (Expr)typeSwitch.getResult();
    }
}
